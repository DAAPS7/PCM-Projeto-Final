---
title: "MusicaInator 3000"
format:
  dashboard: 
    orientation: columns
    scrolling: false
    page-layout: none
    css: assets/css/style.css
    code-copy: false
    fill: true
    logo: assets/img/logo.png
    include-in-header:
      text: |
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
        <link rel="icon" href="assets/img/logo.png">
---

## Column

### Row 1 {height=80vh}

```{ojs}
//| include: false
//| echo: false

// Audio Context object
audioContext = new AudioContext();
audioEl = document.createElement("audio")
audioEl.controls = true
document.body.appendChild(audioEl)
audioEl.hidden = true

```

```{ojs}
//| include: false
//| echo: false

async function audioPlayback(audioFile) {
    let sourceNode;
    let analyser;

    if (audioContext.state === "suspended") {
        await audioContext.resume();
    }

    // Create nodes once
    if (!sourceNode) {
        analyser = audioContext.createAnalyser();
        sourceNode = audioContext.createMediaElementSource(audioEl);
        sourceNode.connect(analyser);
        analyser.connect(audioContext.destination);
    }

    audioEl.src = URL.createObjectURL(audioFile);
    audioEl.load();
}

async function audioRecognitionAPI(audioFile) {
    const token = "c68dc7c96dc75ce14c48740ab7bf4b08";

    const formData = new FormData();
    formData.append("api_token", token);
    formData.append("file", audioFile);
    formData.append("return", "apple_music,spotify");
    formData.append("accurate_offsets", "true");
    formData.append("skip", "3");
    formData.append("every", "1");

    const response = await fetch("https://api.audd.io/", {
        method: "POST",
        body: formData
    });

    const data = await response.json();
    console.log(data);
    return data;
}

```

```{ojs}
//| include: false
//| echo: false

songPopularity = resultAPI ? `Popularity: ${resultAPI?.result?.spotify?.popularity}` : "Popularity"

```

```{ojs}
//| include: false
//| echo: false

trackName = resultAPI ? resultAPI.result.title : "Waiting for track..."

```

```{ojs}
//| include: false
//| echo: false

artistName = resultAPI ? resultAPI.result.artist : "Waiting for artist..."

```

```{ojs}
//| include: false
//| echo: false

mutable audioTime = 0;

audioEl.addEventListener("timeupdate", () => {
    mutable audioTime = audioEl.currentTime;
    syncLyrics();
});
songDuration = resultAPI ? audioEl.duration : "0:00"

```

```{ojs}
//| include: false
//| echo: false

imageURL = resultAPI?.result?.spotify?.album?.images[0]?.url ?? "https://placehold.co/400?text=No+Art"

```

```{ojs}
//| include: false
//| echo: false

spotifyTimeCode = resultAPI?.result?.timecode ?? "Duration"

```

```{ojs}
//| include: false
//| echo: false

albumName = resultAPI?.result?.album ?? "Album"

```

```{ojs}
//| include: false
//| echo: false

releaseDate = resultAPI?.result?.release_date ?? "Release Date"

```

```{ojs}
//| expandable: false
//| classes: song-card

controlsSection = html `<section id="controls"></section>`;

visualizationDropdown = html`<div class="control-group">
    <select id="visualizationType">
      <option value="spectrum">Frequency Spectrum</option>
      <option value="waveform">Waveform</option>
      <option value="particles">Particles</option>
      <option value="reactiveBall">Reactive Ball</option>
    </select>
  </div>`;

root = html`
  <div class="control-group">
    <label class="uploadButton">
      <input id="upload-input" type="file" accept="audio/*" />
    </label>
  </div>
`;

appendControls = {
  controlsSection.appendChild(visualizationDropdown);
  controlsSection.appendChild(root);
}

viewof audioFile = {
  const input = root.querySelector("input");

  root.value = null;

  input.addEventListener("change", () => {
    root.value = input.files;  
    root.dispatchEvent(new Event("input"));
  });

  return root;
}

// Criar bot√£o de remover a musica atual

app = {
  if (!resultAPI) return null;

  const { App } = await import("/assets/js/App.js");
  const { AudioProcessor } = await import("/assets/js/AudioProcessor.js");
  const { VisualizationEngine } = await import("/assets/js/VisualizationEngine.js");
  const { App } = await import("/assets/js/App.js");
  const { App } = await import("/assets/js/App.js");
  const { App } = await import("/assets/js/App.js");

  return new App();
}

resultAPI = {  
  if (!audioFile || audioFile.length === 0) return null;

  const file = audioFile[0];     
  audioPlayback(file);
  app.loadAudioFile(file);

  const res = await audioRecognitionAPI(file);
  return res;
}

canvas = html `<canvas id="audioCanvas"></canvas>`;

mainApp = {

}

canvasDraw = {
  const canvasParent = canvas.parentElement;
  if(canvasParent) {
    canvas.width = canvasParent.clientWidth;
    canvas.height = canvasParent.clientHeight * 2;
  }

  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "white";
  //ctx.fillRect(0, 0, canvas.width, canvas.height);
}

```

```{ojs}
//| expandable: false
//| classes: lyrics-card

// Lyric API call
lyrics = {
    // Don't fetch if we don't have real data yet
    if (!resultAPI || !resultAPI.result) {
        return null;
    }

    let query = {
        track_name: trackName,
        artist_name: artistName
    }

    const params = new URLSearchParams(query);
    const response = await fetch(`https://lrclib.net/api/get?${params}`);
    const data = await response.json();

    return data
}

// Process the lyrics string with the timestamps into an object
processedLyrics = {
  if(!lyrics?.syncedLyrics) return null;

  const str = lyrics?.syncedLyrics;
  const lyricsArray = [];
  let lyricLine = "";
  let index = 0;
  let latestTime = 0;

  for (let i = 0; i < str.length; i++) {
    if (str[i] === "[") {
      const minutes = parseInt(str[i + 1] + str[i + 2]);
      const seconds = parseInt(str[i + 4] + str[i + 5]);
      const decimal = parseFloat("0." + str[i + 7] + str[i + 8]);
      const timeInSeconds = minutes * 60 + seconds + decimal;

      if (i !== 0) {
        if (lyricLine.trim() !== "") {
          lyricsArray.push({
            index: index,
            timestamp: latestTime,
            line: lyricLine.trim(),
          });
        }
        index++;
      }

      latestTime = timeInSeconds;

      lyricLine = "";
      i += 10;
    }

    lyricLine += str[i];
  }

  return lyricsArray;
}

// classes for highlighting: "past-lyric", "present-lyric", "future-lyric"
// Create a div for each lyric line (spotify like) and find a way to highlight and scroll with synchronization

lyricsArray = processedLyrics;
lyricsDiv = html `<div class="lyrics"></div>`;

generateDivs = {
  if(!lyricsArray) {
    lyricsDiv.textContent = "No lyrics available yet.";
    return;
  } 

  lyricsDiv.textContent = "";

  lyricsArray.forEach(element => {
    lyricsDiv.appendChild(html `<div class="lyric-line future-lyric" id="line-${element.index}">${element.line}</div>`)
  });
}

mutable currentIndex = -1

function syncLyrics() {
  if(!lyricsArray || lyricsArray.length === 0) return;
  
  const currentTime = audioEl.currentTime;
  
  // Find the active lyric index based on current time
  let newIndex = -1;
  for(let i = lyricsArray.length - 1; i >= 0; i--) {
    if(lyricsArray[i].timestamp <= currentTime) {
      newIndex = i;
      break;
    }
  }
  
  // Only update if index changed
  if(newIndex !== currentIndex) {
    // Remove styling from old current line
    if(currentIndex >= 0) {
      const oldLine = lyricsDiv.querySelector(`#line-${currentIndex}`);
      if(oldLine) {
        oldLine.classList.replace('present-lyric', 'past-lyric');
      }
    }
    
    // Update mutable variable
    mutable currentIndex = newIndex;
    
    // Add styling to new current line
    if(newIndex >= 0) {
      const newLine = lyricsDiv.querySelector(`#line-${newIndex}`);
      if(newLine) {
        newLine.classList.remove('past-lyric', 'future-lyric');
        newLine.classList.add('present-lyric');

        newLine.scrollIntoView({ 
          behavior: 'smooth',
          block: 'start'
        });
      }
    }
  }
}
```

### Row 2 {height=15vh}

```{ojs}
//| expandable: false
//| classes: play-bar-card

function formatTime(sec) {
    const flooredSec = Math.floor(sec);

    const minutes = Math.floor(sec/60);
    const seconds = Math.floor(sec % 60);

    if(seconds < 10)
        return `${minutes}:0${seconds}`;
    else
        return `${minutes}:${seconds}`;

}

// Whole play bar HTML
playBar = html`
  <div class="playBar">
    <div class="songDetails">
      <img id="artwork" src="https://placehold.co/400?text=No+Art">
      <div id="textBox">
        <p id="song">Waiting for track...</p>
        <p id="artist">Waiting for artist...</p>
      </div>
    </div>

    <div class="mediaButtons">
      <div class="player-buttons">
        <button class="backwards-button icon-button" disabled>
          <i class="fa-solid fa-step-backward"></i>
        </button>

        <button class="playButton" disabled>
          <i id="play-icon" class="fa-solid fa-play"></i>
        </button>

        <button class="repeat-button icon-button" disabled>
          <i class="fa-solid fa-repeat"></i>
        </button>
      </div>

      <div class="media-bar">
        <span class="song-time current-time">0:00</span>
        <div class="progress-bar">
          <div class="progress-fill"></div>
        </div>
        <span class="song-time duration">0:00</span>
      </div>
    </div>

    <div class="settingsButtons">
      <button id="volume-button" class="icon-button">
        <i class="fa-solid fa-volume-up"></i>
      </button>
      <div class="volume-bar">
        <div class="volume-fill"></div>
      </div>
    </div>
  </div>
`;

mediaButtonsEvents = {
    const playButton = playBar.querySelector(".mediaButtons .player-buttons .playButton");
    const backwardsButton = playBar.querySelector(".mediaButtons .player-buttons .backwards-button");
    const repeatButton = playBar.querySelector(".mediaButtons .player-buttons .repeat-button");
    const playIcon = playButton.querySelector("#play-icon");

    let songPlaying = false;

    playButton.onclick = () => {
        songPlaying = !songPlaying;
        songPlaying ? audioEl.play() : audioEl.pause();
        playIcon.className = songPlaying
        ? "fa-solid fa-pause"
        : "fa-solid fa-play";
    };

    backwardsButton.onclick = () => {
        audioEl.currentTime = 0;
    };
    
    let repeat = false;

    repeatButton.onclick = () => {
        repeat = !repeat;
        repeat ? repeatButton.style.color = "blue" : repeatButton.style.color = "white";
        audioEl.loop = repeat;
    };

    playBar;
}

timeUpdate = {
    audioEl.addEventListener("timeupdate", () => {
      playBar.querySelector(".current-time").textContent = formatTime(audioEl.currentTime);

      const progress =
          audioEl.currentTime / audioEl.duration || 0;

      playBar.querySelector(".progress-fill").style.width =
          `${progress * 100}%`;
      
      const playButton = playBar.querySelector(".mediaButtons .player-buttons .playButton");
      const playIcon = playButton.querySelector("#play-icon");
      
      if(audioEl.ended)
        playIcon.className = "fa-solid fa-play";
    });

    return 0;
}

htmlUpdate = {
    // Don't update if audio isn't fully loaded
    if (!resultAPI) return;

    document.getElementById("upload-input").disabled = true;

    playBar.querySelector("#song").textContent = trackName;
    playBar.querySelector("#artist").textContent = artistName;
    playBar.querySelector("#artwork").src = imageURL;
    playBar.querySelector(".duration").textContent = formatTime(songDuration);

    playBar.querySelector(".playButton").disabled = false;
    playBar.querySelector(".backwards-button").disabled = false;
    playBar.querySelector(".repeat-button").disabled = false;

    return 0;
}

timeSelection = {
    const progressBar = playBar.querySelector(".progress-bar");

    progressBar.addEventListener("click", (e) => {
      const rect = progressBar.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const width = rect.width;

      // Calculate new time
      const newTime = (clickX / width) * audioEl.duration;
      audioEl.currentTime = newTime;
    });

    return 0;
}

function setVolumeIcon(volume, element) {
  if(volume >= 0.5) {
      element.className = "fa-solid fa-volume-up";
  } else if(volume === 0) {
      element.className = "fa-solid fa-volume-off";
  } else {
      element.className = "fa-solid fa-volume-down";
  }
}

volumeSelection = {
  const volumeBar = playBar.querySelector(".volume-bar");
  const volumeButton = playBar.querySelector("#volume-button");
  const volumeIcon = volumeButton.querySelector("i");

  let muted = false;

  volumeButton.addEventListener("click", (e) => {
    muted = !muted;
    audioEl.muted = muted;

    if(muted) {
      setVolumeIcon(0, volumeIcon);
      playBar.querySelector(".volume-fill").style.width = "0%";
    } else {
      setVolumeIcon(audioEl.volume, volumeIcon);
      playBar.querySelector(".volume-fill").style.width =
      `${audioEl.volume * 100}%`;
    }
  });

  volumeBar.addEventListener("click", (e) => {
    const rect = volumeBar.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const width = rect.width;

    // Calculate new time
    let currentVolume = (clickX / width);

    if(currentVolume <= 0) currentVolume = 0;
    audioEl.volume = currentVolume;

    setVolumeIcon(currentVolume, volumeIcon);

    playBar.querySelector(".volume-fill").style.width =
      `${audioEl.volume * 100}%`;
  });

  return 0;
}
```